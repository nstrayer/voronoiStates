<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <div id = "viz"></div>
    <script>
        d3.selection.prototype.moveToFront = function() {
            return this.each(function() {
                this.parentNode.appendChild(this);
            });
        };

        var width = parseInt(d3.select("#viz").style("width").slice(0, -2)),
            height = $(window).height() - 5,
            vertices,
            colors = ['rgb(166,206,227)','rgb(31,120,180)','rgb(178,223,138)','rgb(51,160,44)','rgb(251,154,153)','rgb(227,26,28)','rgb(253,191,111)','rgb(255,127,0)','rgb(202,178,214)','rgb(106,61,154)','rgb(255,255,153)','rgb(177,89,40)'];

        var voronoi = d3.geom.voronoi()

        var svg = d3.select("#viz").append("svg")
            .attr("width", width)
            .attr("height", height)

        var vPath = svg.append("g").selectAll(".voronoi");

        var projection = d3.geo.albers()
            .scale(width * 1.025)
            .translate([width / 2, height / 2]);

        var projection = d3.geo.mercator()
            .scale(1000)
            .center([-109, 43]);

        var path = d3.geo.path()
            .projection(projection);

        var g = svg.append("g")

        //Set up the queue so that all the stuff shows up at the same time. Also, the code is cleaner
        queue()
            .defer(d3.json, "data/us-10m.json")
            // .defer(d3.csv,"data/ikeas.csv")
            .defer(d3.csv,"data/marketData_small.csv")
            .await(ready);

        function ready(error, us, markets) {

            // us.objects.cb_2013_us_state_20m.geometries =
            //     us.objects.cb_2013_us_state_20m.geometries.filter(
            //         function(d){if(["Alaska", "Hawaii", "Puerto Rico"].indexOf(d.id) == -1){return d}}
            //     )
            console.log(markets)

            var limits   = topojson.feature(us, us.objects.land);
            var exterior = projectLineString(limits, projection);

            function polygon(d) {
                return "M" + d.join("L") + "Z";
            }

            vertices = markets.map(function(d) {
                return projection([+d.x,+d.y]);
            });

            var inFrame = [];
            $.each(vertices, function(i, loc){
                if((loc[0] < width && loc[0] > 0) && (loc[1] < height && loc[1] > 0)){
                    inFrame.push(loc)
                }
            });
            vertices = inFrame;

            // g.append("g") //re-enable after land boundries have been implemented
            //     .attr("id", "states")
            //     .selectAll(".states")
            //     .data(topojson.feature(us, us.objects.states).features)
            //     .enter().append("path")
            //     .attr("class", "states")
            //     .attr("d", path)

            // g.append("path")
            //     .datum(limits)
            //     .attr("class", "limits")
            //     .attr("d", path);

            svg.selectAll("circle")
                .data(vertices.slice(1))
                .enter().append("circle")
                .attr("transform", function(d) { return "translate(" + d + ")"; })
                .attr("r", 1)
                .attr("fill", "steelblue")
                .moveToFront()

            svg.append("g")
                .attr("class", "land")
              .selectAll(".voronoi")
                // .data(voronoi(vertices.map(projection)).map(function(d) {
                //   // Each voronoi region is a convex polygon, therefore we can use
                //   // d3.geom.polygon.clip, treating each regino as a clip region, with the
                //   // projected “exterior” as a subject polygon.
                //   return d3.geom.polygon(d).clip(exterior.slice());
                // }))
                .data(voronoi(vertices), polygon)
              .enter().append("path")
                .attr("class", "voronoi")
                .style("fill", function(d,i){return colors[i%11]})
                .style("opacity", 0.8)
                .attr("d", polygon);
        }

        // Extracts a single LineString from the given feature, projected (and
        // resampled) using the given projection.
        function projectLineString(feature, projection) {
          var line;
          d3.geo.stream(feature, projection.stream({
            polygonStart: noop,
            polygonEnd: noop,
            lineStart: function() { line = []; },
            lineEnd: noop,
            point: function(x, y) { line.push([x, y]); },
            sphere: noop
          }));
          return line;
        }

        function noop() {}

    </script>
